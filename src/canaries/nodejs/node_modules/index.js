const { URL } = require('url');
// const synthetics = require('Synthetics');
// const log = require('SyntheticsLogger');
// const syntheticsConfiguration = synthetics.getConfiguration();

// const AWS = require('aws-sdk');
// const s3 = new AWS.S3();
// const cloudWatch = new AWS.CloudWatch();

// Test pipeline
// const test = "test";

let AWS = undefined
let s3 = undefined
let cloudWatch = undefined;

let synthetics = undefined
let log = undefined
let syntheticsConfiguration = undefined

// maximum number of links that would be followed
const limit = 10;

const getBrokenLinks = async function (page) {
    let links = []

    const aTagInHTML = await page.evaluateHandle(() => {
        return document.getElementsByTagName('a');
    });

    const numberOfLinks = await page.evaluate(e => e.length, aTagInHTML);

    for (let i = 0; i < (numberOfLinks < limit ? numberOfLinks : limit); i++) {
        let element = await page.evaluate((aTagInHTML, i, links) => {
        let element = aTagInHTML[i];
        let url = String(element.href).trim();
        // // Condition for grabbing a link
        if (url != null && url.length > 0 && !links.includes(url) && (url.startsWith('http') || url.startsWith('https'))) {
            return {url};
        }
        } , aTagInHTML, i, links);

        if (element) { 
            links.push(element.url)
        }
    }

    let brokenLinkCount = 0;

    for (let i = 0; i < links.length; i++) {
        fetch(links[i]).then((response) => {
            log.info(`Visit links: ${links[i]}`);
            if (response.status < 200 || response.status > 299) {
                    brokenLinkCount += 1;
            }
        })
    }

    return brokenLinkCount
}


const loadUrl = async function (page, url) {
    let domcontentloaded = false;

    await synthetics.executeStep(url, async function () {
        const start = Date.now()
        const response = await page.goto(url, { waitUntil: ['domcontentloaded'], timeout: 30000 });

        const time = Date.now() - start;
        log.info(`page load took: ${time}ms`)

        if (response) {
            domcontentloaded = true;

            const numberOfBrokenLinks = await getBrokenLinks(page)


            log.info(`number of broken links: ${numberOfBrokenLinks}`)

            var params = {
                MetricData: [
                    {
                        MetricName: process.env.METRIC_LATENCY_NAME,
                        Dimensions: [
                            {
                                Name: 'url',
                                Value: url
                            }
                        ],
                        Unit: 'Milliseconds',
                        Value: time
                    },
                    {
                        MetricName: process.env.METRIC_AVAILABILITY_NAME,
                        Dimensions: [
                            {
                                Name: 'url',
                                Value: url
                            }
                        ],
                        Unit: 'Count',
                        Value: (response.status() < 200 || response.status() > 299) ? 0 : 1
                    },
                    {
                        MetricName: process.env.METRIC_BROKENLINKS_NAME,
                        Dimensions: [
                            {
                                Name: 'url',
                                Value: url
                            }
                        ],
                        Unit: 'Count',
                        Value: numberOfBrokenLinks
                    }
                ],
                Namespace: process.env.METRIC_NAMESPACE
            };

            try {
                let data = await cloudWatch.putMetricData(params).promise();
                log.info('putMetricData', JSON.stringify(data));
            } catch (e) {
                log.error('Error putting metric data', e);
            }

            if (response.status() < 200 || response.status() > 299) {
                throw new Error(`Failed to load url: ${url} ${response.status()} ${response.statusText()}`);
            }
        } else {
            const logNoResponseString = `No response returned for url: ${url}`;
            log.error(logNoResponseString);
            throw new Error(logNoResponseString);
        }

        // Wait for 3 seconds to let page load fully before taking the screenshot on which visual testing will be performed.
        await new Promise(r => setTimeout(r, 5000));

        // If not doing this then the screenshot can not be stored -> failed
        // Because the s3 will be confused between the "/" in the link or "/" in directory path
        var realSiteUrl = url.replace("https://", "").split("/")[0]
        await synthetics.takeScreenshot(realSiteUrl, 'loaded');

        // Percentage variance of screen shot 02-www.porsche.com-loaded.png when compared with its base screenshot is 0.01% and variance threshold is 5%
        
        // | filter @message like /Percentage variance of screen shot/
        // | parse @message "Percentage variance of screen shot *-*-loaded.png when compared with its base screenshot is *% and variance threshold is 5%" as num, web, percent
        // | sort @timestamp desc
        // | limit 1000

        // 2024-06-26T01:18:37.050Z INFO: Percentage variance of screen shot 01-www.swinburne.edu.au-loaded.png when compared with its base screenshot is 0% and variance threshold is 5%
        
        // 2024-06-26T01:19:11.644Z INFO: Percentage variance of screen shot 02-www.porsche.com-loaded.png when compared with its base screenshot is 0.04% and variance threshold is 5%

        // /aws/lambda/cwsyn-canary-8b9e648e-37e9-4c80-83d0-c52be2d29833

        // arn:aws:logs:ap-southeast-2:058264550947:log-group:canary:*
    });
};

const canary = async function (testMode) {
    // must be inside the function for canary test
    AWS = require('aws-sdk');
    s3 = new AWS.S3();
    cloudWatch = new AWS.CloudWatch();

    if (!testMode) {
        // These libs are only available on the AWS runtime environment, so it cannot be tested locally
        synthetics = require('Synthetics');
        log = require('SyntheticsLogger');
        syntheticsConfiguration = synthetics.getConfiguration();
    }

    const bucketName = process.env.BUCKET;
    const objectKey = "data/webCrawler.json"; // <- No /data

    const params = {
        Bucket: bucketName, // your bucket name
        Key: objectKey // path to the object you're looking for
    };

    const urls = [];

    try {
        const data = await s3.getObject(params).promise();
        const jsonContent = data.Body.toString('utf-8');
        const jsonData = JSON.parse(jsonContent);
        for (const website of jsonData.websites) {
            urls.push(website.url);
        }
    } catch (error) {
        console.error('Error fetching S3 object:', error);
        // throw error;
    }

    /* Disabling default step screen shots taken during Synthetics.executeStep() calls
     * Step will be used to publish metrics on time taken to load dom content but
     * Screenshots will be taken outside the executeStep to allow for page to completely load with domcontentloaded
     * You can change it to load, networkidle0, networkidle2 depending on what works best for you.
     */
    if (!testMode) {
        syntheticsConfiguration.disableStepScreenshots();
        syntheticsConfiguration.setConfig({
            continueOnStepFailure: true,
            includeRequestHeaders: true, // Enable if headers should be displayed in HAR
            includeResponseHeaders: true, // Enable if headers should be displayed in HAR
            restrictedHeaders: [], // Value of these headers will be redacted from logs and reports
            restrictedUrlParameters: [] // Values of these url parameters will be redacted from logs and reports
        });
    }

    /* Enable visual testing on a screenshot taken using the method takeScreenshot
    Screenshots taken in the current test run will be compared against screenshots taken in the base test run
    When a new canary is created, the first successful run will be chosen as the base test run
    A test run can be made a base run by passing it's baseTestRunId in the updateCanary API or using the Synthetics AWS console
    You can opt-in or opt-out a screenshot on which visual testing operation will be performed using the updateCanary API or the Synthetics AWS console
    */
    if(!testMode) {
        syntheticsConfiguration.withVisualCompareWithBaseRun(true);

    }
    /* By default, when there is a difference between the base and current screenshot, the canary fails.
    You can configure the variance threshold percentage below which the canary won't fail using the withVisualVarianceThresholdPercentage method
    You can draw an area/boundary on the base screenshot which will be ignored during visual testing operation.
    You can draw ignore boundaries and export the coordinates to other clients like CloudFormation or SDK using the Synthetics AWS console. The boundary coordinates can also be exported us
    */
    if (!testMode) {
        syntheticsConfiguration.withVisualVarianceThresholdPercentage(5);
        syntheticsConfiguration.withFailCanaryRunOnVisualVariance(false);
    }
    
    // await synthetics.launch({
    //     defaultViewport: { 
    //         "deviceScaleFactor": 1, 
    //         "width": 800,
    //         "height": 600 
    // }});

    if (!testMode) {
        if (urls.length > 0) {
            let page = await synthetics.getPage();

            for (const url of urls) {
                await loadUrl(page, url);
            }
        }
    }
    
    if (testMode) {
        return urls;
    }
};

exports.handler = async (testMode = false) => {
    return await canary(testMode);
};


